<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · GeometricOptimizers.jl</title><meta name="title" content="Home · GeometricOptimizers.jl"/><meta property="og:title" content="Home · GeometricOptimizers.jl"/><meta property="twitter:title" content="Home · GeometricOptimizers.jl"/><meta name="description" content="Documentation for GeometricOptimizers.jl."/><meta property="og:description" content="Documentation for GeometricOptimizers.jl."/><meta property="twitter:description" content="Documentation for GeometricOptimizers.jl."/><meta property="og:url" content="https://JuliaGNI.github.io/GeometricOptimizers.jl/"/><meta property="twitter:url" content="https://JuliaGNI.github.io/GeometricOptimizers.jl/"/><link rel="canonical" href="https://JuliaGNI.github.io/GeometricOptimizers.jl/"/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>GeometricOptimizers.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li><li><a class="tocitem" href="references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaGNI/GeometricOptimizers.jl/blob/main/docs/src/index.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="GeometricOptimizers"><a class="docs-heading-anchor" href="#GeometricOptimizers">GeometricOptimizers</a><a id="GeometricOptimizers-1"></a><a class="docs-heading-anchor-permalink" href="#GeometricOptimizers" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/JuliaGNI/GeometricOptimizers.jl">GeometricOptimizers</a>.</p><ul><li><a href="#Base.Matrix-Tuple{GlobalSection}"><code>Base.Matrix</code></a></li><li><a href="#GeometricOptimizers.AbstractCache"><code>GeometricOptimizers.AbstractCache</code></a></li><li><a href="#GeometricOptimizers.AbstractLieAlgHorMatrix"><code>GeometricOptimizers.AbstractLieAlgHorMatrix</code></a></li><li><a href="#GeometricOptimizers.AbstractTriangular"><code>GeometricOptimizers.AbstractTriangular</code></a></li><li><a href="#GeometricOptimizers.Adam"><code>GeometricOptimizers.Adam</code></a></li><li><a href="#GeometricOptimizers.AdamCache"><code>GeometricOptimizers.AdamCache</code></a></li><li><a href="#GeometricOptimizers.AdamWithDecay"><code>GeometricOptimizers.AdamWithDecay</code></a></li><li><a href="#GeometricOptimizers.BFGS"><code>GeometricOptimizers.BFGS</code></a></li><li><a href="#GeometricOptimizers.BFGSCache"><code>GeometricOptimizers.BFGSCache</code></a></li><li><a href="#GeometricOptimizers.GlobalSection"><code>GeometricOptimizers.GlobalSection</code></a></li><li><a href="#GeometricOptimizers.Gradient"><code>GeometricOptimizers.Gradient</code></a></li><li><a href="#GeometricOptimizers.GradientCache"><code>GeometricOptimizers.GradientCache</code></a></li><li><a href="#GeometricOptimizers.GrassmannLieAlgHorMatrix"><code>GeometricOptimizers.GrassmannLieAlgHorMatrix</code></a></li><li><a href="#GeometricOptimizers.GrassmannLieAlgHorMatrix-Tuple{AbstractMatrix, Int64}"><code>GeometricOptimizers.GrassmannLieAlgHorMatrix</code></a></li><li><a href="#GeometricOptimizers.GrassmannManifold"><code>GeometricOptimizers.GrassmannManifold</code></a></li><li><a href="#GeometricOptimizers.LowerTriangular-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T"><code>GeometricOptimizers.LowerTriangular</code></a></li><li><a href="#GeometricOptimizers.LowerTriangular"><code>GeometricOptimizers.LowerTriangular</code></a></li><li><a href="#GeometricOptimizers.Manifold"><code>GeometricOptimizers.Manifold</code></a></li><li><a href="#GeometricOptimizers.Momentum"><code>GeometricOptimizers.Momentum</code></a></li><li><a href="#GeometricOptimizers.MomentumCache"><code>GeometricOptimizers.MomentumCache</code></a></li><li><a href="#GeometricOptimizers.Optimizer"><code>GeometricOptimizers.Optimizer</code></a></li><li><a href="#GeometricOptimizers.Optimizer-Tuple{GeometricOptimizers.OptimizerMethod, NamedTuple}"><code>GeometricOptimizers.Optimizer</code></a></li><li><a href="#GeometricOptimizers.OptimizerMethod"><code>GeometricOptimizers.OptimizerMethod</code></a></li><li><a href="#GeometricOptimizers.SkewSymMatrix"><code>GeometricOptimizers.SkewSymMatrix</code></a></li><li><a href="#GeometricOptimizers.SkewSymMatrix-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T"><code>GeometricOptimizers.SkewSymMatrix</code></a></li><li><a href="#GeometricOptimizers.StiefelLieAlgHorMatrix"><code>GeometricOptimizers.StiefelLieAlgHorMatrix</code></a></li><li><a href="#GeometricOptimizers.StiefelLieAlgHorMatrix-Tuple{AbstractMatrix, Integer}"><code>GeometricOptimizers.StiefelLieAlgHorMatrix</code></a></li><li><a href="#GeometricOptimizers.StiefelManifold"><code>GeometricOptimizers.StiefelManifold</code></a></li><li><a href="#GeometricOptimizers.StiefelProjection"><code>GeometricOptimizers.StiefelProjection</code></a></li><li><a href="#GeometricOptimizers.StiefelProjection-Union{Tuple{GeometricOptimizers.AbstractLieAlgHorMatrix{T}}, Tuple{T}} where T"><code>GeometricOptimizers.StiefelProjection</code></a></li><li><a href="#GeometricOptimizers.StiefelProjection-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T"><code>GeometricOptimizers.StiefelProjection</code></a></li><li><a href="#GeometricOptimizers.SymmetricMatrix"><code>GeometricOptimizers.SymmetricMatrix</code></a></li><li><a href="#GeometricOptimizers.SymmetricMatrix-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T"><code>GeometricOptimizers.SymmetricMatrix</code></a></li><li><a href="#GeometricOptimizers.UpperTriangular"><code>GeometricOptimizers.UpperTriangular</code></a></li><li><a href="#GeometricOptimizers.UpperTriangular-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T"><code>GeometricOptimizers.UpperTriangular</code></a></li><li><a href="#Base.:*-Tuple{GlobalSection, Manifold}"><code>Base.:*</code></a></li><li><a href="#Base.rand-Union{Tuple{MT}, Tuple{Type{MT}, Integer, Integer}} where MT&lt;:Manifold"><code>Base.rand</code></a></li><li><a href="#Base.rand-Union{Tuple{MT}, Tuple{KernelAbstractions.Backend, Type{MT}, Integer, Integer}} where MT&lt;:Manifold"><code>Base.rand</code></a></li><li><a href="#Base.vec-Tuple{GeometricOptimizers.AbstractTriangular}"><code>Base.vec</code></a></li><li><a href="#Base.vec-Tuple{SkewSymMatrix}"><code>Base.vec</code></a></li><li><a href="#Base.vec-Tuple{StiefelLieAlgHorMatrix}"><code>Base.vec</code></a></li><li><a href="#GeometricOptimizers.apply_section-Union{Tuple{AT}, Tuple{T}, Tuple{GlobalSection{T, AT}, AT}} where {T, AT&lt;:(StiefelManifold{T, AT} where AT&lt;:AbstractMatrix{T})}"><code>GeometricOptimizers.apply_section</code></a></li><li><a href="#GeometricOptimizers.apply_section!-Union{Tuple{AT}, Tuple{T}, Tuple{AT, GlobalSection{T, AT}, AT}} where {T, AT&lt;:(StiefelManifold{T, AT} where AT&lt;:AbstractMatrix{T})}"><code>GeometricOptimizers.apply_section!</code></a></li><li><a href="#GeometricOptimizers.cayley-Union{Tuple{T}, Tuple{Manifold{T}, AbstractMatrix{T}}} where T"><code>GeometricOptimizers.cayley</code></a></li><li><a href="#GeometricOptimizers.cayley-Tuple{GrassmannLieAlgHorMatrix}"><code>GeometricOptimizers.cayley</code></a></li><li><a href="#GeometricOptimizers.cayley-Tuple{StiefelLieAlgHorMatrix}"><code>GeometricOptimizers.cayley</code></a></li><li><a href="#GeometricOptimizers.geodesic-Tuple{StiefelLieAlgHorMatrix}"><code>GeometricOptimizers.geodesic</code></a></li><li><a href="#GeometricOptimizers.geodesic-Tuple{GrassmannLieAlgHorMatrix}"><code>GeometricOptimizers.geodesic</code></a></li><li><a href="#GeometricOptimizers.geodesic-Union{Tuple{T}, Tuple{Manifold{T}, AbstractMatrix{T}}} where T"><code>GeometricOptimizers.geodesic</code></a></li><li><a href="#GeometricOptimizers.global_rep-Union{Tuple{AT}, Tuple{T}, Tuple{GlobalSection{T, AT}, AbstractMatrix{T}}} where {T, AT&lt;:(StiefelManifold{T, AT} where AT&lt;:AbstractMatrix{T})}"><code>GeometricOptimizers.global_rep</code></a></li><li><a href="#GeometricOptimizers.global_rep-Union{Tuple{AT}, Tuple{T}, Tuple{GlobalSection{T, AT}, AbstractMatrix{T}}} where {T, AT&lt;:(GrassmannManifold{T, AT} where AT&lt;:AbstractMatrix{T})}"><code>GeometricOptimizers.global_rep</code></a></li><li><a href="#GeometricOptimizers.global_section-Union{Tuple{StiefelManifold{T, AT} where AT&lt;:AbstractMatrix{T}}, Tuple{T}} where T"><code>GeometricOptimizers.global_section</code></a></li><li><a href="#GeometricOptimizers.global_section-Union{Tuple{GrassmannManifold{T, AT} where AT&lt;:AbstractMatrix{T}}, Tuple{T}} where T"><code>GeometricOptimizers.global_section</code></a></li><li><a href="#GeometricOptimizers.init_optimizer_cache-Tuple{GeometricOptimizers.OptimizerMethod, Any}"><code>GeometricOptimizers.init_optimizer_cache</code></a></li><li><a href="#GeometricOptimizers.metric-Tuple{GrassmannManifold, AbstractMatrix, AbstractMatrix}"><code>GeometricOptimizers.metric</code></a></li><li><a href="#GeometricOptimizers.metric-Tuple{StiefelManifold, AbstractMatrix, AbstractMatrix}"><code>GeometricOptimizers.metric</code></a></li><li><a href="#GeometricOptimizers.optimization_step!-Tuple{Optimizer, NamedTuple, NamedTuple, NamedTuple}"><code>GeometricOptimizers.optimization_step!</code></a></li><li><a href="#GeometricOptimizers.rgrad-Tuple{GrassmannManifold, AbstractMatrix}"><code>GeometricOptimizers.rgrad</code></a></li><li><a href="#GeometricOptimizers.rgrad-Tuple{StiefelManifold, AbstractMatrix}"><code>GeometricOptimizers.rgrad</code></a></li><li><a href="#GeometricOptimizers.update!-Tuple{Optimizer, GeometricOptimizers.AbstractCache, AbstractArray}"><code>GeometricOptimizers.update!</code></a></li><li><a href="#GeometricOptimizers.update!-Tuple{Optimizer{&lt;:GeometricOptimizers.BFGS}, GeometricOptimizers.BFGSCache, AbstractArray}"><code>GeometricOptimizers.update!</code></a></li><li><a href="#GeometricOptimizers.Ω-Union{Tuple{T}, Tuple{GrassmannManifold{T, AT} where AT&lt;:AbstractMatrix{T}, AbstractMatrix{T}}} where T"><code>GeometricOptimizers.Ω</code></a></li><li><a href="#GeometricOptimizers.Ω-Union{Tuple{T}, Tuple{StiefelManifold{T, AT} where AT&lt;:AbstractMatrix{T}, AbstractMatrix{T}}} where T"><code>GeometricOptimizers.Ω</code></a></li><li><a href="#GeometricOptimizers.𝔄-Tuple{AbstractMatrix}"><code>GeometricOptimizers.𝔄</code></a></li><li><a href="#GeometricOptimizers.𝔄-Tuple{AbstractMatrix, AbstractMatrix}"><code>GeometricOptimizers.𝔄</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Matrix-Tuple{GlobalSection}" href="#Base.Matrix-Tuple{GlobalSection}"><code>Base.Matrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Matrix(λY::GlobalSection)</code></pre><p>Put <code>λY</code> into matrix form. </p><p>This is not recommended if speed is important!</p><p>Use <a href="#GeometricOptimizers.apply_section-Union{Tuple{AT}, Tuple{T}, Tuple{GlobalSection{T, AT}, AT}} where {T, AT&lt;:(StiefelManifold{T, AT} where AT&lt;:AbstractMatrix{T})}"><code>apply_section</code></a> and <a href="#GeometricOptimizers.global_rep-Union{Tuple{AT}, Tuple{T}, Tuple{GlobalSection{T, AT}, AbstractMatrix{T}}} where {T, AT&lt;:(GrassmannManifold{T, AT} where AT&lt;:AbstractMatrix{T})}"><code>global_rep</code></a> instead!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricOptimizers.jl/blob/6f4b3d30e5da75b97306ec0085ca25a2503725eb/src/global_sections/global_sections.jl#L33-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricOptimizers.AbstractCache" href="#GeometricOptimizers.AbstractCache"><code>GeometricOptimizers.AbstractCache</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractCache</code></pre><p><code>AbstractCache</code> has subtypes: <a href="#GeometricOptimizers.AdamCache"><code>AdamCache</code></a>, <a href="#GeometricOptimizers.MomentumCache"><code>MomentumCache</code></a>, <a href="#GeometricOptimizers.GradientCache"><code>GradientCache</code></a> and <a href="#GeometricOptimizers.BFGSCache"><code>BFGSCache</code></a>.</p><p>All of them can be initialized with providing an array (also supporting manifold types).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricOptimizers.jl/blob/6f4b3d30e5da75b97306ec0085ca25a2503725eb/src/optimizers/optimizer_caches.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricOptimizers.AbstractLieAlgHorMatrix" href="#GeometricOptimizers.AbstractLieAlgHorMatrix"><code>GeometricOptimizers.AbstractLieAlgHorMatrix</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractLieAlgHorMatrix &lt;: AbstractMatrix</code></pre><p><code>AbstractLieAlgHorMatrix</code> is a supertype for various horizontal components of Lie algebras. We usually call this <span>$\mathfrak{g}^\mathrm{hor}$</span>.</p><p>See <a href="#GeometricOptimizers.StiefelLieAlgHorMatrix"><code>StiefelLieAlgHorMatrix</code></a> and <a href="#GeometricOptimizers.GrassmannLieAlgHorMatrix"><code>GrassmannLieAlgHorMatrix</code></a> for concrete examples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricOptimizers.jl/blob/6f4b3d30e5da75b97306ec0085ca25a2503725eb/src/lie_algebras/abstract_lie_algebra_horizontal.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricOptimizers.AbstractTriangular" href="#GeometricOptimizers.AbstractTriangular"><code>GeometricOptimizers.AbstractTriangular</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractTriangular</code></pre><p>See <a href="#GeometricOptimizers.UpperTriangular"><code>UpperTriangular</code></a> and <a href="#GeometricOptimizers.LowerTriangular"><code>LowerTriangular</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricOptimizers.jl/blob/6f4b3d30e5da75b97306ec0085ca25a2503725eb/src/special_matrices/triangular.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricOptimizers.Adam" href="#GeometricOptimizers.Adam"><code>GeometricOptimizers.Adam</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Adam(η, ρ₁, ρ₂, δ)</code></pre><p>Make an instance of the Adam Optimizer.</p><p>Here the cache consists of first and second moments that are updated as </p><p class="math-container">\[B_1 \gets ((\rho_1 - \rho_1^t)/(1 - \rho_1^t))\cdot{}B_1 + (1 - \rho_1)/(1 - \rho_1^t)\cdot{}\nabla{}L,\]</p><p>and</p><p class="math-container">\[B_2 \gets ((\rho_2 - \rho_1^t)/(1 - \rho_2^t))\cdot{}B_2 + (1 - \rho_2)/(1 - \rho_2^t)\cdot\nabla{}L\odot\nabla{}L.\]</p><p>The final velocity is computed as:</p><p class="math-container">\[\mathrm{velocity} \gets -\eta{}B_1/\sqrt{B_2 + \delta}.\]</p><p><strong>Implementation</strong></p><p>The <em>velocity</em> is stored in the input to save memory:</p><pre><code class="language-julia hljs">mul!(B, -o.method.η, /ᵉˡᵉ(C.B₁, scalar_add(racᵉˡᵉ(C.B₂), o.method.δ)))</code></pre><p>where <code>B</code> is the input to the [<code>update!</code>] function.</p><p>The algorithm and suggested defaults are taken from [<a href="references/#goodfellow2016deep">1</a>, page 301].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricOptimizers.jl/blob/6f4b3d30e5da75b97306ec0085ca25a2503725eb/src/optimizers/adam_optimizer.jl#L1-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricOptimizers.AdamCache" href="#GeometricOptimizers.AdamCache"><code>GeometricOptimizers.AdamCache</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AdamCache(Y)</code></pre><p>Store the first and second moment for <code>Y</code> (initialized as zeros).</p><p>First and second moments are called <code>B₁</code> and <code>B₂</code>.</p><p>If the cache is called with an instance of a homogeneous space, e.g. the <a href="#GeometricOptimizers.StiefelManifold"><code>StiefelManifold</code></a> <span>$St(n,N)$</span> it initializes the moments as elements of <span>$\mathfrak{g}^\mathrm{hor}$</span> (<a href="#GeometricOptimizers.StiefelLieAlgHorMatrix"><code>StiefelLieAlgHorMatrix</code></a>).</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using GeometricOptimizers

Y = rand(StiefelManifold, 5, 3)
GeometricOptimizers.AdamCache(Y).B₁

# output

5×5 StiefelLieAlgHorMatrix{Float64, SkewSymMatrix{Float64, Vector{Float64}}, Matrix{Float64}}:
 0.0  -0.0  -0.0  -0.0  -0.0
 0.0   0.0  -0.0  -0.0  -0.0
 0.0   0.0   0.0  -0.0  -0.0
 0.0   0.0   0.0   0.0   0.0
 0.0   0.0   0.0   0.0   0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricOptimizers.jl/blob/6f4b3d30e5da75b97306ec0085ca25a2503725eb/src/optimizers/optimizer_caches.jl#L13-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricOptimizers.AdamWithDecay" href="#GeometricOptimizers.AdamWithDecay"><code>GeometricOptimizers.AdamWithDecay</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AdamWithDecay(n_epochs, η₁=1f-2, η₂=1f-6, ρ₁=9f-1, ρ₂=9.9f-1, δ=1f-8)</code></pre><p>Make an instance of the Adam Optimizer with weight decay.</p><p>All except the first argument (the number of epochs) have defaults.</p><p>The difference to the standard <a href="#GeometricOptimizers.Adam"><code>Adam</code></a> is that we change the learning reate <span>$\eta$</span> in each step. Apart from the <em>time dependency</em> of <span>$\eta$</span> the two algorithms are however equivalent. <span>$\eta(0)$</span> starts with a high value <span>$\eta_1$</span> and then exponentially decrease until it reaches <span>$\eta_2$</span> with</p><p class="math-container">\[ \eta(t) = \gamma^t\eta_1,\]</p><p>where <span>$\gamma = \exp(\log(\eta_1 / \eta_2) / \mathtt{n\_epochs}).$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricOptimizers.jl/blob/6f4b3d30e5da75b97306ec0085ca25a2503725eb/src/optimizers/adam_optimizer_with_decay.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricOptimizers.BFGS" href="#GeometricOptimizers.BFGS"><code>GeometricOptimizers.BFGS</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BFGS(η, δ)</code></pre><p>Make an instance of the Broyden-Fletcher-Goldfarb-Shanno (BFGS) optimizer. </p><p><code>η</code> is the <em>learning rate</em>. <code>δ</code> is a stabilization parameter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricOptimizers.jl/blob/6f4b3d30e5da75b97306ec0085ca25a2503725eb/src/optimizers/bfgs_optimizer.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricOptimizers.BFGSCache" href="#GeometricOptimizers.BFGSCache"><code>GeometricOptimizers.BFGSCache</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BFGSCache(B)</code></pre><p>Make the cache for the BFGS optimizer based on the array <code>B</code>.</p><p>It stores an array for the gradient of the previous time step <code>B</code> and the inverse of the Hessian matrix <code>H</code>.</p><p>The cache for the inverse of the Hessian is initialized with the idendity. The cache for the previous gradient information is initialized with the zero vector.</p><p>Note that the cache for <code>H</code> is changed iteratively, whereas the cache for <code>B</code> is newly assigned at every time step.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricOptimizers.jl/blob/6f4b3d30e5da75b97306ec0085ca25a2503725eb/src/optimizers/bfgs_cache.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricOptimizers.GlobalSection" href="#GeometricOptimizers.GlobalSection"><code>GeometricOptimizers.GlobalSection</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GlobalSection(Y)</code></pre><p>Construct a global section for <code>Y</code>.  </p><p>A global section <span>$\lambda$</span> is a mapping from a homogeneous space <span>$\mathcal{M}$</span> to the corresponding Lie group <span>$G$</span> such that </p><p class="math-container">\[\lambda(Y)E = Y,\]</p><p>Also see <a href="#GeometricOptimizers.apply_section-Union{Tuple{AT}, Tuple{T}, Tuple{GlobalSection{T, AT}, AT}} where {T, AT&lt;:(StiefelManifold{T, AT} where AT&lt;:AbstractMatrix{T})}"><code>apply_section</code></a> and <a href="#GeometricOptimizers.global_rep-Union{Tuple{AT}, Tuple{T}, Tuple{GlobalSection{T, AT}, AbstractMatrix{T}}} where {T, AT&lt;:(GrassmannManifold{T, AT} where AT&lt;:AbstractMatrix{T})}"><code>global_rep</code></a>.</p><p><strong>Implementation</strong></p><p>For an implementation of <code>GlobalSection</code> for a custom array (especially manifolds), the function <a href="#GeometricOptimizers.global_section-Union{Tuple{GrassmannManifold{T, AT} where AT&lt;:AbstractMatrix{T}}, Tuple{T}} where T"><code>global_section</code></a> has to be generalized.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricOptimizers.jl/blob/6f4b3d30e5da75b97306ec0085ca25a2503725eb/src/global_sections/global_sections.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricOptimizers.Gradient" href="#GeometricOptimizers.Gradient"><code>GeometricOptimizers.Gradient</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Gradient(η)</code></pre><p>Make an instance of a gradient optimizer. </p><p>This is the simplest neural network optimizer. It has no cache and computes the final velocity as:</p><p class="math-container">\[    \mathrm{velocity} \gets - \eta\nabla_\mathrm{weight}L.\]</p><p><strong>Implementation</strong></p><p>The operations are done as memory efficiently as possible. This means the provided <span>$\nabla_WL$</span> is mutated via:</p><pre><code class="language-julia hljs">rmul!(∇L, -method.η)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricOptimizers.jl/blob/6f4b3d30e5da75b97306ec0085ca25a2503725eb/src/optimizers/gradient_optimizer.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricOptimizers.GradientCache" href="#GeometricOptimizers.GradientCache"><code>GeometricOptimizers.GradientCache</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GradientCache(Y)</code></pre><p>Do not store anything.</p><p>The cache for the <a href="#GeometricOptimizers.Gradient"><code>Gradient</code></a> does not consider past information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricOptimizers.jl/blob/6f4b3d30e5da75b97306ec0085ca25a2503725eb/src/optimizers/optimizer_caches.jl#L79-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricOptimizers.GrassmannLieAlgHorMatrix" href="#GeometricOptimizers.GrassmannLieAlgHorMatrix"><code>GeometricOptimizers.GrassmannLieAlgHorMatrix</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GrassmannLieAlgHorMatrix(B::AbstractMatrix, N::Integer, n::Integer)</code></pre><p>Build an instance of <code>GrassmannLieAlgHorMatrix</code> based on an arbitrary matrix <code>B</code> of size <span>$(N-n)\times{}n$</span>.</p><p><code>GrassmannLieAlgHorMatrix</code> is the <em>horizontal component of the Lie algebra of skew-symmetric matrices</em> (with respect to the canonical metric).</p><p><strong>Extended help</strong></p><p>The projection here is: <span>$\pi:S \to SE/\sim$</span> where </p><p class="math-container">\[E = \begin{bmatrix} \mathbb{I}_{n} \\ \mathbb{O}_{(N-n)\times{}n}  \end{bmatrix},\]</p><p>and the equivalence relation is </p><p class="math-container">\[V_1 \sim V_2 \iff \exists A\in\mathcal{S}_\mathrm{skew}(n) \text{ such that } V_2 = V_1 + \begin{bmatrix} A \\ \mathbb{O} \end{bmatrix}\]</p><p>An element of GrassmannLieAlgMatrix takes the form: </p><p class="math-container">\[\begin{pmatrix}
\bar{\mathbb{O}} &amp; B^T \\ B &amp; \mathbb{O}
\end{pmatrix},\]</p><p>where <span>$\bar{\mathbb{O}}\in\mathbb{R}^{n\times{}n}$</span> and <span>$\mathbb{O}\in\mathbb{R}^{(N - n)\times(N-n)}.$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricOptimizers.jl/blob/6f4b3d30e5da75b97306ec0085ca25a2503725eb/src/lie_algebras/grassmann_lie_algebra_horizontal.jl#L1-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricOptimizers.GrassmannLieAlgHorMatrix-Tuple{AbstractMatrix, Int64}" href="#GeometricOptimizers.GrassmannLieAlgHorMatrix-Tuple{AbstractMatrix, Int64}"><code>GeometricOptimizers.GrassmannLieAlgHorMatrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GrassmannLieAlgHorMatrix(D::AbstractMatrix, n::Integer)</code></pre><p>Take a big matrix as input and build an instance of <code>GrassmannLieAlgHorMatrix</code>.</p><p>The integer <span>$N$</span> in <span>$Gr(n, N)$</span> here is the number of rows of <code>D</code>.</p><p><strong>Extended help</strong></p><p>If the constructor is called with a big <span>$N\times{}N$</span> matrix, then the projection is performed the following way: </p><p class="math-container">\[\begin{pmatrix}
A &amp; B_1  \\
B_2 &amp; D
\end{pmatrix} \mapsto 
\begin{pmatrix}
\bar{\mathbb{O}} &amp; -B_2^T \\ 
B_2 &amp; \mathbb{O}
\end{pmatrix}.\]</p><p>This can also be seen as the operation:</p><p class="math-container">\[D \mapsto \Omega(E, DE - EE^TDE),\]</p><p>where <span>$\Omega$</span> is the horizontal lift <a href="#GeometricOptimizers.Ω-Union{Tuple{T}, Tuple{GrassmannManifold{T, AT} where AT&lt;:AbstractMatrix{T}, AbstractMatrix{T}}} where T"><code>GeometricOptimizers.Ω</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricOptimizers.jl/blob/6f4b3d30e5da75b97306ec0085ca25a2503725eb/src/lie_algebras/grassmann_lie_algebra_horizontal.jl#L43-L71">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricOptimizers.GrassmannManifold" href="#GeometricOptimizers.GrassmannManifold"><code>GeometricOptimizers.GrassmannManifold</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GrassmannManifold &lt;: Manifold</code></pre><p>The <code>GrassmannManifold</code> is based on the <a href="#GeometricOptimizers.StiefelManifold"><code>StiefelManifold</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricOptimizers.jl/blob/6f4b3d30e5da75b97306ec0085ca25a2503725eb/src/manifolds/grassmann_manifold.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricOptimizers.LowerTriangular" href="#GeometricOptimizers.LowerTriangular"><code>GeometricOptimizers.LowerTriangular</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LowerTriangular(S::AbstractVector, n::Int)</code></pre><p>Build a lower-triangular matrix from a vector.</p><p>A lower-triangular matrix is an <span>$n\times{}n$</span> matrix that has zeros on the diagonal and on the upper triangular.</p><p>The data are stored in a vector <span>$S$</span> similarly to other matrices. See <a href="#GeometricOptimizers.UpperTriangular"><code>UpperTriangular</code></a>, <a href="#GeometricOptimizers.SkewSymMatrix"><code>SkewSymMatrix</code></a> and <a href="#GeometricOptimizers.SymmetricMatrix"><code>SymmetricMatrix</code></a>.</p><p>The struct two fields: <code>S</code> and <code>n</code>. The first stores all the entries of the matrix in a sparse fashion (in a vector) and the second is the dimension <span>$n$</span> for <span>$A\in\mathbb{R}^{n\times{}n}$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using GeometricOptimizers
S = [1, 2, 3, 4, 5, 6]
LowerTriangular(S, 4)

# output

4×4 LowerTriangular{Int64, Vector{Int64}}:
 0  0  0  0
 1  0  0  0
 2  3  0  0
 4  5  6  0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricOptimizers.jl/blob/6f4b3d30e5da75b97306ec0085ca25a2503725eb/src/special_matrices/lower_triangular.jl#L1-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricOptimizers.LowerTriangular-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T" href="#GeometricOptimizers.LowerTriangular-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T"><code>GeometricOptimizers.LowerTriangular</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LowerTriangular(A::AbstractMatrix)</code></pre><p>Build a lower-triangular matrix from a matrix.</p><p>This is done by taking the lower left of that matrix.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using GeometricOptimizers
M = [1 2 3 4; 5 6 7 8; 9 10 11 12; 13 14 15 16]
LowerTriangular(M)

# output

4×4 LowerTriangular{Int64, Vector{Int64}}:
  0   0   0  0
  5   0   0  0
  9  10   0  0
 13  14  15  0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricOptimizers.jl/blob/6f4b3d30e5da75b97306ec0085ca25a2503725eb/src/special_matrices/lower_triangular.jl#L32-L53">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricOptimizers.Manifold" href="#GeometricOptimizers.Manifold"><code>GeometricOptimizers.Manifold</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Manifold &lt;: AbstractMatrix</code></pre><p>A manifold in <code>GeometricOptimizers</code> is a sutype of <code>AbstractMatrix</code>. All manifolds are matrix manifolds and therefore stored as matrices. More details can be found in the docstrings for the <a href="#GeometricOptimizers.StiefelManifold"><code>StiefelManifold</code></a> and the <a href="#GeometricOptimizers.GrassmannManifold"><code>GrassmannManifold</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricOptimizers.jl/blob/6f4b3d30e5da75b97306ec0085ca25a2503725eb/src/manifolds/abstract_manifold.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricOptimizers.Momentum" href="#GeometricOptimizers.Momentum"><code>GeometricOptimizers.Momentum</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Momentum(η, α)</code></pre><p>Make an instance of the momentum optimizer.</p><p>The momentum optimizer is similar to the <a href="#GeometricOptimizers.Gradient"><code>Gradient</code></a>. It however has a nontrivial cache that stores past history (see <a href="#GeometricOptimizers.MomentumCache"><code>MomentumCache</code></a>). The cache is updated via:</p><p class="math-container">\[    B^{\mathrm{cache}} \gets \alpha{}B^{\mathrm{cache}} + \nabla_\mathrm{weights}L\]</p><p>and then the final velocity is computed as</p><p class="math-container">\[    \mathrm{velocity} \gets  - \eta{}B^{\mathrm{cache}}.\]</p><p><strong>Implementation</strong></p><p>To save memory the <em>velocity</em> is stored in the input <span>$\nabla_WL$</span>. This is similar to the case of the <a href="#GeometricOptimizers.Gradient"><code>Gradient</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricOptimizers.jl/blob/6f4b3d30e5da75b97306ec0085ca25a2503725eb/src/optimizers/momentum_optimizer.jl#L1-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricOptimizers.MomentumCache" href="#GeometricOptimizers.MomentumCache"><code>GeometricOptimizers.MomentumCache</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MomentumCache(Y)</code></pre><p>Store the moment for <code>Y</code> (initialized as zeros).</p><p>The moment is called <code>B</code>.</p><p>If the cache is called with an instance of a <a href="#GeometricOptimizers.Manifold"><code>Manifold</code></a> it initializes the moments as elements of <span>$\mathfrak{g}^\mathrm{hor}$</span> (<a href="#GeometricOptimizers.AbstractLieAlgHorMatrix"><code>AbstractLieAlgHorMatrix</code></a>).</p><p>See <a href="#GeometricOptimizers.AdamCache"><code>AdamCache</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricOptimizers.jl/blob/6f4b3d30e5da75b97306ec0085ca25a2503725eb/src/optimizers/optimizer_caches.jl#L56-L66">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricOptimizers.Optimizer" href="#GeometricOptimizers.Optimizer"><code>GeometricOptimizers.Optimizer</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Optimizer(method, cache, step, retraction)</code></pre><p>Store the <code>method</code> (e.g. <a href="#GeometricOptimizers.Adam"><code>Adam</code></a> with corresponding hyperparameters), the <code>cache</code> (e.g. <a href="#GeometricOptimizers.AdamCache"><code>AdamCache</code></a>), the optimization step and the retraction.</p><p>It takes as input an optimization method and the parameters of a network. </p><p>Before one can call <code>Optimizer</code> a <a href="#GeometricOptimizers.OptimizerMethod"><code>OptimizerMethod</code></a> that stores all the hyperparameters of the optimizer needs to be specified. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricOptimizers.jl/blob/6f4b3d30e5da75b97306ec0085ca25a2503725eb/src/optimizers/optimizer.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricOptimizers.Optimizer-Tuple{GeometricOptimizers.OptimizerMethod, NamedTuple}" href="#GeometricOptimizers.Optimizer-Tuple{GeometricOptimizers.OptimizerMethod, NamedTuple}"><code>GeometricOptimizers.Optimizer</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Optimizer(method, nn_params)</code></pre><p>Allocate the cache for a specific <code>method</code> and <code>nn_params</code> for an instance of <code>Optimizer</code>.</p><p>Internally this calls <a href="#GeometricOptimizers.init_optimizer_cache-Tuple{GeometricOptimizers.OptimizerMethod, Any}"><code>init_optimizer_cache</code></a>.</p><p>An equivalent constructor is</p><pre><code class="language-julia hljs">Optimizer(method, nn::NeuralNetwork)</code></pre><p><strong>Arguments</strong></p><p>The optional keyword argument is the retraction. By default this is <a href="#GeometricOptimizers.cayley-Tuple{GrassmannLieAlgHorMatrix}"><code>cayley</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricOptimizers.jl/blob/6f4b3d30e5da75b97306ec0085ca25a2503725eb/src/optimizers/optimizer.jl#L19-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricOptimizers.OptimizerMethod" href="#GeometricOptimizers.OptimizerMethod"><code>GeometricOptimizers.OptimizerMethod</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">OptimizerMethod</code></pre><p>Each <code>Optimizer</code> has to be called with an <code>OptimizerMethod</code>. This specifies how the neural network weights are updated in each optimization step.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricOptimizers.jl/blob/6f4b3d30e5da75b97306ec0085ca25a2503725eb/src/optimizers/optimizer_method.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricOptimizers.SkewSymMatrix" href="#GeometricOptimizers.SkewSymMatrix"><code>GeometricOptimizers.SkewSymMatrix</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SkewSymMatrix(S::AbstractVector, n::Integer)</code></pre><p>Instantiate a skew-symmetric matrix with information stored in vector <code>S</code>.</p><p>A skew-symmetric matrix <span>$A$</span> is a matrix <span>$A^T = -A$</span>.</p><p>Internally the <code>struct</code> saves a vector <span>$S$</span> of size <span>$n(n-1)\div2$</span>. The conversion is done the following way: </p><p class="math-container">\[[A]_{ij} = \begin{cases} 0                             &amp; \text{if $i=j$} \\
                         S[( (i-2) (i-1) ) \div 2 + j] &amp; \text{if $i&gt;j$}\\ 
                         S[( (j-2) (j-1) ) \div 2 + i] &amp; \text{else}. \end{cases}\]</p><p>So <span>$S$</span> stores a string of vectors taken from <span>$A$</span>: <span>$S = [\tilde{a}_1, \tilde{a}_2, \ldots, \tilde{a}_n]$</span> with <span>$\tilde{a}_i = [[A]_{i1},[A]_{i2},\ldots,[A]_{i(i-1)}]$</span>.</p><p>Also see <a href="#GeometricOptimizers.SymmetricMatrix"><code>SymmetricMatrix</code></a>, <a href="#GeometricOptimizers.LowerTriangular"><code>LowerTriangular</code></a> and <a href="#GeometricOptimizers.UpperTriangular"><code>UpperTriangular</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using GeometricOptimizers
S = [1, 2, 3, 4, 5, 6]
SkewSymMatrix(S, 4)

# output

4×4 SkewSymMatrix{Int64, Vector{Int64}}:
 0  -1  -2  -4
 1   0  -3  -5
 2   3   0  -6
 4   5   6   0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricOptimizers.jl/blob/6f4b3d30e5da75b97306ec0085ca25a2503725eb/src/special_matrices/skew_symmetric.jl#L1-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricOptimizers.SkewSymMatrix-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T" href="#GeometricOptimizers.SkewSymMatrix-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T"><code>GeometricOptimizers.SkewSymMatrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SkewSymMatrix(A::AbstractMatrix)</code></pre><p>Perform <code>0.5 * (A - A&#39;)</code> and store the matrix in an efficient way (as a vector with <span>$n(n-1)/2$</span> entries).</p><p>If the constructor is called with a matrix as input it returns a skew-symmetric matrix via the projection:</p><p class="math-container">\[A \mapsto \frac{1}{2}(A - A^T).\]</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using GeometricOptimizers
M = [1 2 3 4; 5 6 7 8; 9 10 11 12; 13 14 15 16]
SkewSymMatrix(M)

# output

4×4 SkewSymMatrix{Float64, Vector{Float64}}:
 0.0  -1.5  -3.0  -4.5
 1.5   0.0  -1.5  -3.0
 3.0   1.5   0.0  -1.5
 4.5   3.0   1.5   0.0</code></pre><p><strong>Extended help</strong></p><p>Note that the constructor is designed in such a way that it always returns matrices of type <code>SkewSymMatrix{&lt;:AbstractFloat}</code> when called with a matrix, even if this matrix is of type <code>AbstractMatrix{&lt;:Integer}</code>.</p><p>If the user wishes to allocate a matrix <code>SkewSymMatrix{&lt;:Integer}</code> then call:</p><pre><code class="language-julia hljs">SkewSymMatrix(::AbstractVector, n::Integer)</code></pre><p>Note that this is different from <a href="#GeometricOptimizers.LowerTriangular"><code>LowerTriangular</code></a> and <a href="#GeometricOptimizers.UpperTriangular"><code>UpperTriangular</code></a> as no porjection takes place there.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricOptimizers.jl/blob/6f4b3d30e5da75b97306ec0085ca25a2503725eb/src/special_matrices/skew_symmetric.jl#L44-L80">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricOptimizers.StiefelLieAlgHorMatrix" href="#GeometricOptimizers.StiefelLieAlgHorMatrix"><code>GeometricOptimizers.StiefelLieAlgHorMatrix</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">StiefelLieAlgHorMatrix(A::SkewSymMatrix, B::AbstractMatrix, N::Integer, n::Integer)</code></pre><p>Build an instance of <code>StiefelLieAlgHorMatrix</code> based on a skew-symmetric matrix <code>A</code> and an arbitrary matrix <code>B</code>.</p><p>An element of StiefelLieAlgMatrix takes the form: </p><p class="math-container">\[\begin{pmatrix}
A &amp; B^T \\ B &amp; \mathbb{O}
\end{pmatrix},\]</p><p>where <span>$A$</span> is skew-symmetric (this is <a href="#GeometricOptimizers.SkewSymMatrix"><code>SkewSymMatrix</code></a> in <code>GeometricOptimizers</code>).</p><p>Also see <a href="#GeometricOptimizers.GrassmannLieAlgHorMatrix"><code>GrassmannLieAlgHorMatrix</code></a>.</p><p><strong>Extended help</strong></p><p><code>StiefelLieAlgHorMatrix</code> is the <em>horizontal component of the Lie algebra of skew-symmetric matrices</em> (with respect to the canonical metric).</p><p>The projection here is: <span>$\pi:S \to SE$</span> where </p><p class="math-container">\[E = \begin{bmatrix} \mathbb{I}_{n} \\ \mathbb{O}_{(N-n)\times{}n}  \end{bmatrix}.\]</p><p>The matrix <span>$E$</span> is implemented under <a href="#GeometricOptimizers.StiefelProjection"><code>StiefelProjection</code></a> in <code>GeometricOptimizers</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricOptimizers.jl/blob/6f4b3d30e5da75b97306ec0085ca25a2503725eb/src/lie_algebras/stiefel_lie_algebra_horizontal.jl#L1-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricOptimizers.StiefelLieAlgHorMatrix-Tuple{AbstractMatrix, Integer}" href="#GeometricOptimizers.StiefelLieAlgHorMatrix-Tuple{AbstractMatrix, Integer}"><code>GeometricOptimizers.StiefelLieAlgHorMatrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">StiefelLieAlgHorMatrix(D::AbstractMatrix, n::Integer)</code></pre><p>Take a big matrix as input and build an instance of <code>StiefelLieAlgHorMatrix</code>.</p><p>The integer <span>$N$</span> in <span>$St(n, N)$</span> is the number of rows of <code>D</code>.</p><p><strong>Extended help</strong></p><p>If the constructor is called with a big <span>$N\times{}N$</span> matrix, then the projection is performed the following way: </p><p class="math-container">\[\begin{pmatrix}
A &amp; B_1  \\
B_2 &amp; D
\end{pmatrix} \mapsto 
\begin{pmatrix}
\mathrm{skew}(A) &amp; -B_2^T \\ 
B_2 &amp; \mathbb{O}
\end{pmatrix}.\]</p><p>The operation <span>$\mathrm{skew}:\mathbb{R}^{n\times{}n}\to\mathcal{S}_\mathrm{skew}(n)$</span> is the skew-symmetrization operation. This is equivalent to calling of <a href="#GeometricOptimizers.SkewSymMatrix"><code>SkewSymMatrix</code></a> with an <span>$n\times{}n$</span> matrix.</p><p>This can also be seen as the operation:</p><p class="math-container">\[D \mapsto \Omega(E, DE) = \mathrm{skew}\left(2 \left(\mathbb{I} - \frac{1}{2} E E^T \right) DE E^T\right).\]</p><p>Also see <a href="#GeometricOptimizers.Ω-Union{Tuple{T}, Tuple{GrassmannManifold{T, AT} where AT&lt;:AbstractMatrix{T}, AbstractMatrix{T}}} where T"><code>GeometricOptimizers.Ω</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricOptimizers.jl/blob/6f4b3d30e5da75b97306ec0085ca25a2503725eb/src/lie_algebras/stiefel_lie_algebra_horizontal.jl#L41-L71">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricOptimizers.StiefelManifold" href="#GeometricOptimizers.StiefelManifold"><code>GeometricOptimizers.StiefelManifold</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">StiefelManifold &lt;: Manifold</code></pre><p>An implementation of the Stiefel manifold [<a href="references/#hairer2006geometric">2</a>]. The Stiefel manifold is the collection of all matrices <span>$Y\in\mathbb{R}^{N\times{}n}$</span> whose columns are orthonormal, i.e. </p><p class="math-container">\[    St(n, N) = \{Y: Y^TY = \mathbb{I}_n \}.\]</p><p>The Stiefel manifold can be shown to have manifold structure (as the name suggests) and this is heavily used in <code>GeometricOptimizers</code>. It is further a compact space.  More information can be found in the docstrings for <a href="#GeometricOptimizers.rgrad-Tuple{StiefelManifold, AbstractMatrix}"><code>rgrad(::StiefelManifold, ::AbstractMatrix)</code></a> and <a href="#GeometricOptimizers.metric-Tuple{StiefelManifold, AbstractMatrix, AbstractMatrix}"><code>metric(::StiefelManifold, ::AbstractMatrix, ::AbstractMatrix)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricOptimizers.jl/blob/6f4b3d30e5da75b97306ec0085ca25a2503725eb/src/manifolds/stiefel_manifold.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricOptimizers.StiefelProjection" href="#GeometricOptimizers.StiefelProjection"><code>GeometricOptimizers.StiefelProjection</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">StiefelProjection(backend, T, N, n)</code></pre><p>Make a matrix of the form <span>$\begin{bmatrix} \mathbb{I} &amp; \mathbb{O} \end{bmatrix}^T$</span> for a specific backend and data type.</p><p>An array that essentially does <code>vcat(I(n), zeros(N-n, n))</code> with GPU support. </p><p><strong>Extended help</strong></p><p>An instance of <code>StiefelProjection</code> should technically also belong to <a href="#GeometricOptimizers.StiefelManifold"><code>StiefelManifold</code></a>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricOptimizers.jl/blob/6f4b3d30e5da75b97306ec0085ca25a2503725eb/src/special_matrices/stiefel_projection.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricOptimizers.StiefelProjection-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T" href="#GeometricOptimizers.StiefelProjection-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T"><code>GeometricOptimizers.StiefelProjection</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">StiefelProjection(A::AbstractMatrix)</code></pre><p>Extract necessary information from <code>A</code> and build an instance of <code>StiefelProjection</code>. </p><p>Necessary information here referes to the backend, the data type and the size of the matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricOptimizers.jl/blob/6f4b3d30e5da75b97306ec0085ca25a2503725eb/src/special_matrices/stiefel_projection.jl#L24-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricOptimizers.StiefelProjection-Union{Tuple{GeometricOptimizers.AbstractLieAlgHorMatrix{T}}, Tuple{T}} where T" href="#GeometricOptimizers.StiefelProjection-Union{Tuple{GeometricOptimizers.AbstractLieAlgHorMatrix{T}}, Tuple{T}} where T"><code>GeometricOptimizers.StiefelProjection</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">StiefelProjection(B::AbstractLieAlgHorMatrix)</code></pre><p>Extract necessary information from <code>B</code> and build an instance of <code>StiefelProjection</code>. </p><p>Necessary information here referes to the backend, the data type and the size of the matrix.</p><p>The size is queried through <code>B.N</code> and <code>B.n</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using GeometricOptimizers
using GeometricOptimizers: StiefelProjection

B₁ = rand(StiefelLieAlgHorMatrix, 5, 2)
B₂ = rand(GrassmannLieAlgHorMatrix, 5, 2)
E = [1. 0.; 0. 1.; 0. 0.; 0. 0.; 0. 0.]

StiefelProjection(B₁) ≈ StiefelProjection(B₂) ≈ E 

# output

true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricOptimizers.jl/blob/6f4b3d30e5da75b97306ec0085ca25a2503725eb/src/lie_algebras/stiefel_projection.jl#L1-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricOptimizers.SymmetricMatrix" href="#GeometricOptimizers.SymmetricMatrix"><code>GeometricOptimizers.SymmetricMatrix</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SymmetricMatrix(S::AbstractVector, n::Integer)</code></pre><p>Instantiate a symmetric matrix with information stored in vector <code>S</code>.</p><p>A <code>SymmetricMatrix</code> <span>$A$</span> is a matrix <span>$A^T = A$</span>.</p><p>Internally the <code>struct</code> saves a vector <span>$S$</span> of size <span>$n(n+1)\div2$</span>. The conversion is done the following way: </p><p class="math-container">\[[A]_{ij} = \begin{cases} S[( (i-1) i ) \div 2 + j] &amp; \text{if $i\geq{}j$}\\ 
                         S[( (j-1) j ) \div 2 + i] &amp; \text{else}. \end{cases}\]</p><p>So <span>$S$</span> stores a string of vectors taken from <span>$A$</span>: <span>$S = [\tilde{a}_1, \tilde{a}_2, \ldots, \tilde{a}_n]$</span> with <span>$\tilde{a}_i = [[A]_{i1},[A]_{i2},\ldots,[A]_{ii}]$</span>.</p><p>Also see <a href="#GeometricOptimizers.SkewSymMatrix"><code>SkewSymMatrix</code></a>, <a href="#GeometricOptimizers.LowerTriangular"><code>LowerTriangular</code></a> and <a href="#GeometricOptimizers.UpperTriangular"><code>UpperTriangular</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using GeometricOptimizers
S = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
SymmetricMatrix(S, 4)

# output

4×4 SymmetricMatrix{Int64, Vector{Int64}}:
 1  2  4   7
 2  3  5   8
 4  5  6   9
 7  8  9  10</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricOptimizers.jl/blob/6f4b3d30e5da75b97306ec0085ca25a2503725eb/src/special_matrices/symmetric.jl#L1-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricOptimizers.SymmetricMatrix-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T" href="#GeometricOptimizers.SymmetricMatrix-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T"><code>GeometricOptimizers.SymmetricMatrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SymmetricMatrix(A::AbstractMatrix)</code></pre><p>Perform a projection and store the matrix in an efficient way (as a vector with <span>$n(n+1)/2$</span> entries).</p><p>If the constructor is called with a matrix as input it returns a symmetric matrix via the <em>projection</em>:</p><p class="math-container">\[A \mapsto \frac{1}{2}(A + A^T).\]</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using GeometricOptimizers
M = [1 2 3 4; 5 6 7 8; 9 10 11 12; 13 14 15 16]
SymmetricMatrix(M)

# output

4×4 SymmetricMatrix{Float64, Vector{Float64}}:
 1.0   3.5   6.0   8.5
 3.5   6.0   8.5  11.0
 6.0   8.5  11.0  13.5
 8.5  11.0  13.5  16.0</code></pre><p><strong>Extended help</strong></p><p>Note that the constructor is designed in such a way that it always returns matrices of type <code>SymmetricMatrix{&lt;:AbstractFloat}</code> when called with a matrix, even if this matrix is of type <code>AbstractMatrix{&lt;:Integer}</code>.</p><p>If the user wishes to allocate a matrix <code>SymmetricMatrix{&lt;:Integer}</code> then call</p><p><span>$julia SymmetricMatrix(::AbstractVector, n::Integer)$</span>`</p><p>Note that this is different from <a href="#GeometricOptimizers.LowerTriangular"><code>LowerTriangular</code></a> and <a href="#GeometricOptimizers.UpperTriangular"><code>UpperTriangular</code></a> as no porjection takes place there.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricOptimizers.jl/blob/6f4b3d30e5da75b97306ec0085ca25a2503725eb/src/special_matrices/symmetric.jl#L43-L79">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricOptimizers.UpperTriangular" href="#GeometricOptimizers.UpperTriangular"><code>GeometricOptimizers.UpperTriangular</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">UpperTriangular(S::AbstractVector, n::Int)</code></pre><p>Build an upper-triangular matrix from a vector.</p><p>An upper-triangular matrix is an <span>$n\times{}n$</span> matrix that has zeros on the diagonal and on the lower triangular.</p><p>The data are stored in a vector <span>$S$</span> similarly to other matrices. See <a href="#GeometricOptimizers.LowerTriangular"><code>LowerTriangular</code></a>, <a href="#GeometricOptimizers.SkewSymMatrix"><code>SkewSymMatrix</code></a> and <a href="#GeometricOptimizers.SymmetricMatrix"><code>SymmetricMatrix</code></a>.</p><p>The struct two fields: <code>S</code> and <code>n</code>. The first stores all the entries of the matrix in a sparse fashion (in a vector) and the second is the dimension <span>$n$</span> for <span>$A\in\mathbb{R}^{n\times{}n}$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using GeometricOptimizers
S = [1, 2, 3, 4, 5, 6]
UpperTriangular(S, 4)

# output

4×4 UpperTriangular{Int64, Vector{Int64}}:
 0  1  2  4
 0  0  3  5
 0  0  0  6
 0  0  0  0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricOptimizers.jl/blob/6f4b3d30e5da75b97306ec0085ca25a2503725eb/src/special_matrices/upper_triangular.jl#L1-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricOptimizers.UpperTriangular-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T" href="#GeometricOptimizers.UpperTriangular-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T"><code>GeometricOptimizers.UpperTriangular</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">UpperTriangular(A::AbstractMatrix)</code></pre><p>Build an upper-triangular matrix from a matrix.</p><p>This is done by taking the upper right of that matrix.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using GeometricOptimizers
M = [1 2 3 4; 5 6 7 8; 9 10 11 12; 13 14 15 16]
UpperTriangular(M)

# output

4×4 UpperTriangular{Int64, Vector{Int64}}:
 0  2  3   4
 0  0  7   8
 0  0  0  12
 0  0  0   0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricOptimizers.jl/blob/6f4b3d30e5da75b97306ec0085ca25a2503725eb/src/special_matrices/upper_triangular.jl#L32-L53">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:*-Tuple{GlobalSection, Manifold}" href="#Base.:*-Tuple{GlobalSection, Manifold}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">λY * Y</code></pre><p>Apply the element <code>λY</code> onto <code>Y</code>.</p><p>Here <code>λY</code> is an element of a Lie group and <code>Y</code> is an element of a homogeneous space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricOptimizers.jl/blob/6f4b3d30e5da75b97306ec0085ca25a2503725eb/src/global_sections/global_sections.jl#L46-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.rand-Union{Tuple{MT}, Tuple{KernelAbstractions.Backend, Type{MT}, Integer, Integer}} where MT&lt;:Manifold" href="#Base.rand-Union{Tuple{MT}, Tuple{KernelAbstractions.Backend, Type{MT}, Integer, Integer}} where MT&lt;:Manifold"><code>Base.rand</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rand(backend, manifold_type, N, n)</code></pre><p>Draw random elements for a specific device.</p><p><strong>Examples</strong></p><p>Random elements of the manifold can be allocated on GPU.  Call ...</p><pre><code class="language-julia hljs">rand(CUDABackend(), StiefelManifold{Float32}, N, n)</code></pre><p>... for drawing elements on a <code>CUDA</code> device.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricOptimizers.jl/blob/6f4b3d30e5da75b97306ec0085ca25a2503725eb/src/manifolds/abstract_manifold.jl#L55-L69">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.rand-Union{Tuple{MT}, Tuple{Type{MT}, Integer, Integer}} where MT&lt;:Manifold" href="#Base.rand-Union{Tuple{MT}, Tuple{Type{MT}, Integer, Integer}} where MT&lt;:Manifold"><code>Base.rand</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rand(manifold_type, N, n)</code></pre><p>Draw random elements from the Stiefel and the Grassmann manifold. </p><p>Because both of these manifolds are compact spaces we can sample them uniformly [<a href="references/#mezzadri2006generate">3</a>].</p><p><strong>Examples</strong></p><p>When we call ...</p><pre><code class="language-julia hljs">using GeometricOptimizers
using GeometricOptimizers: _round # hide
import Random
Random.seed!(123)

N, n = 5, 3
Y = rand(StiefelManifold{Float32}, N, n)
_round(Y; digits = 5) # hide

# output

5×3 StiefelManifold{Float32, Matrix{Float32}}:
 -0.27575   0.32991   0.77275
 -0.62485  -0.33224  -0.0686
 -0.69333   0.36724  -0.18988
 -0.09295  -0.73145   0.46064
  0.2102    0.33301   0.38717</code></pre><p>... the sampling is done by first allocating a random matrix of size <span>$N\times{}n$</span> via <code>Y = randn(Float32, N, n)</code>.</p><p>We then perform a QR decomposition <code>Q, R = qr(Y)</code> with the <code>qr</code> function from the <code>LinearAlgebra</code> package (this is using Householder reflections internally). </p><p>The final output are then the first <code>n</code> columns of the <code>Q</code> matrix. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricOptimizers.jl/blob/6f4b3d30e5da75b97306ec0085ca25a2503725eb/src/manifolds/abstract_manifold.jl#L74-L109">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.vec-Tuple{GeometricOptimizers.AbstractTriangular}" href="#Base.vec-Tuple{GeometricOptimizers.AbstractTriangular}"><code>Base.vec</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">vec(A::AbstractTriangular)</code></pre><p>Return the associated vector to <span>$A$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using GeometricOptimizers

M = [1 2 3 4; 5 6 7 8; 9 10 11 12; 13 14 15 16]
LowerTriangular(M) |&gt; vec

# output

6-element Vector{Int64}:
  5
  9
 10
 13
 14
 15</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricOptimizers.jl/blob/6f4b3d30e5da75b97306ec0085ca25a2503725eb/src/special_matrices/triangular.jl#L103-L126">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.vec-Tuple{SkewSymMatrix}" href="#Base.vec-Tuple{SkewSymMatrix}"><code>Base.vec</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">vec(A)</code></pre><p>Output the associated vector of <code>A</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using GeometricOptimizers

M = [1 2 3 4; 5 6 7 8; 9 10 11 12; 13 14 15 16]
SkewSymMatrix(M) |&gt; vec

# output

6-element Vector{Float64}:
 1.5
 3.0
 1.5
 4.5
 3.0
 1.5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricOptimizers.jl/blob/6f4b3d30e5da75b97306ec0085ca25a2503725eb/src/special_matrices/skew_symmetric.jl#L262-L285">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.vec-Tuple{StiefelLieAlgHorMatrix}" href="#Base.vec-Tuple{StiefelLieAlgHorMatrix}"><code>Base.vec</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">vec(A::StiefelLieAlgHorMatrix)</code></pre><p>Vectorize <code>A</code>. </p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using GeometricOptimizers

A = SkewSymMatrix([1, ], 2)
B = [2 3; ]
B̄ = StiefelLieAlgHorMatrix(A, B, 3, 2)
B̄ |&gt; vec

# output

vcat(1-element Vector{Int64}, 2-element Vector{Int64}):
 1
 2
 3</code></pre><p><strong>Implementation</strong></p><p>This is using <code>Vcat</code> from the package <code>LazyArrays</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricOptimizers.jl/blob/6f4b3d30e5da75b97306ec0085ca25a2503725eb/src/lie_algebras/stiefel_lie_algebra_horizontal.jl#L222-L248">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricOptimizers.apply_section!-Union{Tuple{AT}, Tuple{T}, Tuple{AT, GlobalSection{T, AT}, AT}} where {T, AT&lt;:(StiefelManifold{T, AT} where AT&lt;:AbstractMatrix{T})}" href="#GeometricOptimizers.apply_section!-Union{Tuple{AT}, Tuple{T}, Tuple{AT, GlobalSection{T, AT}, AT}} where {T, AT&lt;:(StiefelManifold{T, AT} where AT&lt;:AbstractMatrix{T})}"><code>GeometricOptimizers.apply_section!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">apply_section!(Y::AT, λY::GlobalSection{T, AT}, Y₂::AT) where {T, AT&lt;:StiefelManifold{T}}</code></pre><p>Apply <code>λY</code> to <code>Y₂</code> and store the result in <code>Y</code>.</p><p>This is the inplace version of <a href="#GeometricOptimizers.apply_section-Union{Tuple{AT}, Tuple{T}, Tuple{GlobalSection{T, AT}, AT}} where {T, AT&lt;:(StiefelManifold{T, AT} where AT&lt;:AbstractMatrix{T})}"><code>apply_section</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricOptimizers.jl/blob/6f4b3d30e5da75b97306ec0085ca25a2503725eb/src/global_sections/global_sections.jl#L71-L77">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricOptimizers.apply_section-Union{Tuple{AT}, Tuple{T}, Tuple{GlobalSection{T, AT}, AT}} where {T, AT&lt;:(StiefelManifold{T, AT} where AT&lt;:AbstractMatrix{T})}" href="#GeometricOptimizers.apply_section-Union{Tuple{AT}, Tuple{T}, Tuple{GlobalSection{T, AT}, AT}} where {T, AT&lt;:(StiefelManifold{T, AT} where AT&lt;:AbstractMatrix{T})}"><code>GeometricOptimizers.apply_section</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">apply_section(λY::GlobalSection{T, AT}, Y₂::AT) where {T, AT &lt;: StiefelManifold{T}}</code></pre><p>Apply <code>λY</code> to <code>Y₂</code>.</p><p>Mathematically this is the group action of the element <span>$\lambda{}Y\in{}G$</span> on the element <span>$Y_2$</span> of the homogeneous space <span>$\mathcal{M}$</span>.</p><p>Internally it calls <a href="#GeometricOptimizers.apply_section!-Union{Tuple{AT}, Tuple{T}, Tuple{AT, GlobalSection{T, AT}, AT}} where {T, AT&lt;:(StiefelManifold{T, AT} where AT&lt;:AbstractMatrix{T})}"><code>apply_section!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricOptimizers.jl/blob/6f4b3d30e5da75b97306ec0085ca25a2503725eb/src/global_sections/global_sections.jl#L55-L63">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricOptimizers.cayley-Tuple{GrassmannLieAlgHorMatrix}" href="#GeometricOptimizers.cayley-Tuple{GrassmannLieAlgHorMatrix}"><code>GeometricOptimizers.cayley</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cayley(B̄::GrassmannLieAlgHorMatrix)</code></pre><p>Compute the Cayley retraction of <code>B</code>.</p><p>This is equivalent to the method of <a href="#GeometricOptimizers.cayley-Tuple{GrassmannLieAlgHorMatrix}"><code>cayley</code></a> for <a href="#GeometricOptimizers.StiefelLieAlgHorMatrix">StiefelLieAlgHorMatrix</a>.</p><p>See <a href="#GeometricOptimizers.cayley-Tuple{StiefelLieAlgHorMatrix}"><code>cayley(::StiefelLieAlgHorMatrix)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricOptimizers.jl/blob/6f4b3d30e5da75b97306ec0085ca25a2503725eb/src/retractions/retractions.jl#L167-L175">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricOptimizers.cayley-Tuple{StiefelLieAlgHorMatrix}" href="#GeometricOptimizers.cayley-Tuple{StiefelLieAlgHorMatrix}"><code>GeometricOptimizers.cayley</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cayley(B̄::StiefelLieAlgHorMatrix)</code></pre><p>Compute the Cayley retraction of <code>B</code>.</p><p><strong>Implementation</strong></p><p>Internally this is using </p><p class="math-container">\[\mathrm{Cayley}(\bar{B}) = \mathbb{I} + \frac{1}{2} B&#39; (\mathbb{I}_{2n} - \frac{1}{2} (B&#39;&#39;)^T B&#39;)^{-1} (B&#39;&#39;)^T (\mathbb{I} + \frac{1}{2} B),\]</p><p>with</p><p class="math-container">\[\bar{B} = \begin{bmatrix}
    A &amp; -B^T \\ 
    B &amp; \mathbb{O}
\end{bmatrix} = \begin{bmatrix}  \frac{1}{2}A &amp; \mathbb{I} \\ B &amp; \mathbb{O} \end{bmatrix} \begin{bmatrix}  \mathbb{I} &amp; \mathbb{O} \\ \frac{1}{2}A &amp; -B^T  \end{bmatrix} =: B&#39;(B&#39;&#39;)^T,\]</p><p>i.e. <span>$\bar{B}$</span> is expressed as a product of two <span>$N\times{}2n$</span> matrices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricOptimizers.jl/blob/6f4b3d30e5da75b97306ec0085ca25a2503725eb/src/retractions/retractions.jl#L132-L152">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricOptimizers.cayley-Union{Tuple{T}, Tuple{Manifold{T}, AbstractMatrix{T}}} where T" href="#GeometricOptimizers.cayley-Union{Tuple{T}, Tuple{Manifold{T}, AbstractMatrix{T}}} where T"><code>GeometricOptimizers.cayley</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cayley(Y::Manifold, Δ)</code></pre><p>Take as input an element of a manifold <code>Y</code> and a tangent vector in <code>Δ</code> in the corresponding tangent space and compute the Cayley retraction.</p><p>In different notation: take as input an element <span>$x$</span> of <span>$\mathcal{M}$</span> and an element of <span>$T_x\mathcal{M}$</span> and return <span>$\mathrm{Cayley}(v_x).$</span> </p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using GeometricOptimizers

Y = StiefelManifold([1. 0. 0.;]&#39; |&gt; Matrix)
Δ = [0. .5 0.;]&#39; |&gt; Matrix
Y₂ = GeometricOptimizers.cayley(Y, Δ)

Y₂&#39; * Y₂ ≈ [1.;]

# output

true</code></pre><p>See the example in [<code>geodesic(::Manifold{T}, ::AbstractMatrix{T}) where T</code>].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricOptimizers.jl/blob/6f4b3d30e5da75b97306ec0085ca25a2503725eb/src/retractions/retractions.jl#L99-L123">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricOptimizers.geodesic-Tuple{GrassmannLieAlgHorMatrix}" href="#GeometricOptimizers.geodesic-Tuple{GrassmannLieAlgHorMatrix}"><code>GeometricOptimizers.geodesic</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">geodesic(B̄::GrassmannLieAlgHorMatrix)</code></pre><p>Compute the geodesic of an element in <a href="#GeometricOptimizers.GrassmannLieAlgHorMatrix"><code>GrassmannLieAlgHorMatrix</code></a>.</p><p>This is equivalent to the method of <a href="#GeometricOptimizers.geodesic-Tuple{GrassmannLieAlgHorMatrix}"><code>geodesic</code></a> for <a href="#GeometricOptimizers.StiefelLieAlgHorMatrix">StiefelLieAlgHorMatrix</a>.</p><p>See <a href="#GeometricOptimizers.geodesic-Tuple{StiefelLieAlgHorMatrix}"><code>geodesic(::StiefelLieAlgHorMatrix)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricOptimizers.jl/blob/6f4b3d30e5da75b97306ec0085ca25a2503725eb/src/retractions/retractions.jl#L78-L86">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricOptimizers.geodesic-Tuple{StiefelLieAlgHorMatrix}" href="#GeometricOptimizers.geodesic-Tuple{StiefelLieAlgHorMatrix}"><code>GeometricOptimizers.geodesic</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">geodesic(B̄::StiefelLieAlgHorMatrix)</code></pre><p>Compute the geodesic of an element in <a href="#GeometricOptimizers.StiefelLieAlgHorMatrix"><code>StiefelLieAlgHorMatrix</code></a>.</p><p><strong>Implementation</strong></p><p>Internally this is using:</p><p class="math-container">\[\mathbb{I} + B&#39;\mathfrak{A}(B&#39;, B&#39;&#39;)B&#39;&#39;,\]</p><p>with </p><p class="math-container">\[\bar{B} = \begin{bmatrix}
    A &amp; -B^T \\ 
    B &amp; \mathbb{O}
\end{bmatrix} = \begin{bmatrix}  \frac{1}{2}A &amp; \mathbb{I} \\ B &amp; \mathbb{O} \end{bmatrix} \begin{bmatrix}  \mathbb{I} &amp; \mathbb{O} \\ \frac{1}{2}A &amp; -B^T  \end{bmatrix} =: B&#39;(B&#39;&#39;)^T.\]</p><p>This is using a computationally efficient version of the matrix exponential <span>$\mathfrak{A}$</span>. </p><p>See <a href="#GeometricOptimizers.𝔄-Tuple{AbstractMatrix, AbstractMatrix}"><code>GeometricOptimizers.𝔄</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricOptimizers.jl/blob/6f4b3d30e5da75b97306ec0085ca25a2503725eb/src/retractions/retractions.jl#L42-L67">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricOptimizers.geodesic-Union{Tuple{T}, Tuple{Manifold{T}, AbstractMatrix{T}}} where T" href="#GeometricOptimizers.geodesic-Union{Tuple{T}, Tuple{Manifold{T}, AbstractMatrix{T}}} where T"><code>GeometricOptimizers.geodesic</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">geodesic(Y::Manifold, Δ)</code></pre><p>Take as input an element of a manifold <code>Y</code> and a tangent vector in <code>Δ</code> in the corresponding tangent space and compute the geodesic (exponential map).</p><p>In different notation: take as input an element <span>$x$</span> of <span>$\mathcal{M}$</span> and an element of <span>$T_x\mathcal{M}$</span> and return <span>$\mathtt{geodesic}(x, v_x) = \exp(v_x).$</span></p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using GeometricOptimizers

Y = StiefelManifold([1. 0. 0.;]&#39; |&gt; Matrix)
Δ = [0. .5 0.;]&#39; |&gt; Matrix
Y₂ = GeometricOptimizers.geodesic(Y, Δ)

Y₂&#39; * Y₂ ≈ [1.;]

# output

true</code></pre><p><strong>Implementation</strong></p><p>Internally this <code>geodesic</code> method calls <a href="#GeometricOptimizers.geodesic-Tuple{StiefelLieAlgHorMatrix}"><code>geodesic(::StiefelLieAlgHorMatrix)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricOptimizers.jl/blob/6f4b3d30e5da75b97306ec0085ca25a2503725eb/src/retractions/retractions.jl#L6-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricOptimizers.global_rep-Union{Tuple{AT}, Tuple{T}, Tuple{GlobalSection{T, AT}, AbstractMatrix{T}}} where {T, AT&lt;:(GrassmannManifold{T, AT} where AT&lt;:AbstractMatrix{T})}" href="#GeometricOptimizers.global_rep-Union{Tuple{AT}, Tuple{T}, Tuple{GlobalSection{T, AT}, AbstractMatrix{T}}} where {T, AT&lt;:(GrassmannManifold{T, AT} where AT&lt;:AbstractMatrix{T})}"><code>GeometricOptimizers.global_rep</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">global_rep(λY::GlobalSection{T, AT}, Δ::AbstractMatrix{T}) where {T, AT&lt;:GrassmannManifold{T}}</code></pre><p>Express <code>Δ</code> (an element of the tangent space of <code>Y</code>) as an instance of <a href="#GeometricOptimizers.GrassmannLieAlgHorMatrix"><code>GrassmannLieAlgHorMatrix</code></a>.</p><p>The method <code>global_rep</code> for <a href="#GeometricOptimizers.GrassmannManifold"><code>GrassmannManifold</code></a> is similar to that for <a href="#GeometricOptimizers.StiefelManifold"><code>StiefelManifold</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using GeometricOptimizers
using GeometricOptimizers: _round
import Random 

Random.seed!(123)

Y = rand(GrassmannManifold, 6, 3)
Δ = rgrad(Y, randn(6, 3))
λY = GlobalSection(Y)

_round(global_rep(λY, Δ); digits = 3)

# output

6×6 GrassmannLieAlgHorMatrix{Float64, Matrix{Float64}}:
  0.0     0.0     0.0     0.981  -2.058   0.4
  0.0     0.0     0.0    -0.424   0.733  -0.919
  0.0     0.0     0.0    -1.815   1.409   1.085
 -0.981   0.424   1.815   0.0     0.0     0.0
  2.058  -0.733  -1.409   0.0     0.0     0.0
 -0.4     0.919  -1.085   0.0     0.0     0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricOptimizers.jl/blob/6f4b3d30e5da75b97306ec0085ca25a2503725eb/src/global_sections/global_sections.jl#L190-L222">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricOptimizers.global_rep-Union{Tuple{AT}, Tuple{T}, Tuple{GlobalSection{T, AT}, AbstractMatrix{T}}} where {T, AT&lt;:(StiefelManifold{T, AT} where AT&lt;:AbstractMatrix{T})}" href="#GeometricOptimizers.global_rep-Union{Tuple{AT}, Tuple{T}, Tuple{GlobalSection{T, AT}, AbstractMatrix{T}}} where {T, AT&lt;:(StiefelManifold{T, AT} where AT&lt;:AbstractMatrix{T})}"><code>GeometricOptimizers.global_rep</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">global_rep(λY::GlobalSection{T, AT}, Δ::AbstractMatrix{T}) where {T, AT&lt;:StiefelManifold{T}}</code></pre><p>Express <code>Δ</code> (an the tangent space of <code>Y</code>) as an instance of <code>StiefelLieAlgHorMatrix</code>.</p><p>This maps an element from <span>$T_Y\mathcal{M}$</span> to an element of <span>$\mathfrak{g}^\mathrm{hor}$</span>. </p><p>These two spaces are isomorphic where the isomorphism where the isomorphism is established through <span>$\lambda(Y)\in{}G$</span> via:</p><p class="math-container">\[T_Y\mathcal{M} \to \mathfrak{g}^{\mathrm{hor}}, \Delta \mapsto \lambda(Y)^{-1}\Omega(Y, \Delta)\lambda(Y).\]</p><p>Also see <a href="#GeometricOptimizers.Ω-Union{Tuple{T}, Tuple{GrassmannManifold{T, AT} where AT&lt;:AbstractMatrix{T}, AbstractMatrix{T}}} where T"><code>GeometricOptimizers.Ω</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using GeometricOptimizers
using GeometricOptimizers: _round
import Random 

Random.seed!(123)

Y = rand(StiefelManifold, 6, 3)
Δ = rgrad(Y, randn(6, 3))
λY = GlobalSection(Y)

_round(global_rep(λY, Δ); digits = 3)

# output

6×6 StiefelLieAlgHorMatrix{Float64, SkewSymMatrix{Float64, Vector{Float64}}, Matrix{Float64}}:
  0.0     0.679   1.925   0.981  -2.058   0.4
 -0.679   0.0     0.298  -0.424   0.733  -0.919
 -1.925  -0.298   0.0    -1.815   1.409   1.085
 -0.981   0.424   1.815   0.0     0.0     0.0
  2.058  -0.733  -1.409   0.0     0.0     0.0
 -0.4     0.919  -1.085   0.0     0.0     0.0</code></pre><p><strong>Implementation</strong></p><p>The function <code>global_rep</code> does in fact not perform the entire map <span>$\lambda(Y)^{-1}\Omega(Y, \Delta)\lambda(Y)$</span> but only</p><p class="math-container">\[\Delta \mapsto \mathrm{skew}(Y^T\Delta),\]</p><p>to get the small skew-symmetric matrix <span>$A\in\mathcal{S}_\mathrm{skew}(n)$</span> and </p><p class="math-container">\[\Delta \mapsto (\lambda(Y)_{[1:N, n:N]}^T \Delta)_{[1:(N-n), 1:n]},\]</p><p>to get the arbitrary matrix <span>$B\in\mathbb{R}^{(N-n)\times{}n}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricOptimizers.jl/blob/6f4b3d30e5da75b97306ec0085ca25a2503725eb/src/global_sections/global_sections.jl#L123-L179">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricOptimizers.global_section-Union{Tuple{GrassmannManifold{T, AT} where AT&lt;:AbstractMatrix{T}}, Tuple{T}} where T" href="#GeometricOptimizers.global_section-Union{Tuple{GrassmannManifold{T, AT} where AT&lt;:AbstractMatrix{T}}, Tuple{T}} where T"><code>GeometricOptimizers.global_section</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">global_section(Y::GrassmannManifold)</code></pre><p>Compute a matrix of size <span>$N\times(N-n)$</span> whose columns are orthogonal to the columns in <code>Y</code>.</p><p>The method <code>global_section</code> for the Grassmann manifold is equivalent to that for the <a href="#GeometricOptimizers.StiefelManifold"><code>StiefelManifold</code></a> (we represent the Grassmann manifold as an embedding in the Stiefel manifold). </p><p>See the documentation for <a href="#GeometricOptimizers.global_section-Union{Tuple{StiefelManifold{T, AT} where AT&lt;:AbstractMatrix{T}}, Tuple{T}} where T"><code>global_section(Y::StiefelManifold{T}) where T</code></a>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricOptimizers.jl/blob/6f4b3d30e5da75b97306ec0085ca25a2503725eb/src/manifolds/grassmann_manifold.jl#L68-L76">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricOptimizers.global_section-Union{Tuple{StiefelManifold{T, AT} where AT&lt;:AbstractMatrix{T}}, Tuple{T}} where T" href="#GeometricOptimizers.global_section-Union{Tuple{StiefelManifold{T, AT} where AT&lt;:AbstractMatrix{T}}, Tuple{T}} where T"><code>GeometricOptimizers.global_section</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">global_section(Y::StiefelManifold)</code></pre><p>Compute a matrix of size <span>$N\times(N-n)$</span> whose columns are orthogonal to the columns in <code>Y</code>.</p><p>This matrix is also called <span>$Y_\perp$</span> [<a href="references/#absil2004riemannian">4</a>–<a href="references/#bendokat2020grassmann">6</a>].</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using GeometricOptimizers
using GeometricOptimizers: global_section
import Random

Random.seed!(123)

Y = StiefelManifold([1. 0.; 0. 1.; 0. 0.; 0. 0.])

round.(Matrix(global_section(Y)); digits = 3)

# output

4×2 Matrix{Float64}:
 0.0    -0.0
 0.0     0.0
 0.936  -0.353
 0.353   0.936</code></pre><p>Further note that we convert the <code>QRCompactWYQ</code> object to a <code>Matrix</code> before we display it.</p><p><strong>Implementation</strong></p><p>The implementation is done with a QR decomposition (<code>LinearAlgebra.qr!</code>). Internally we do: </p><pre><code class="language-julia hljs">A = randn(N, N - n) # or the gpu equivalent
A = A - Y.A * (Y.A&#39; * A)
qr!(A).Q</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricOptimizers.jl/blob/6f4b3d30e5da75b97306ec0085ca25a2503725eb/src/manifolds/stiefel_manifold.jl#L89-L129">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricOptimizers.init_optimizer_cache-Tuple{GeometricOptimizers.OptimizerMethod, Any}" href="#GeometricOptimizers.init_optimizer_cache-Tuple{GeometricOptimizers.OptimizerMethod, Any}"><code>GeometricOptimizers.init_optimizer_cache</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">init_optimizer_cache(method, x)</code></pre><p>Initialize the optimizer cache based on input <code>x</code> for the given <code>method</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricOptimizers.jl/blob/6f4b3d30e5da75b97306ec0085ca25a2503725eb/src/optimizers/optimizer_method.jl#L8-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricOptimizers.metric-Tuple{GrassmannManifold, AbstractMatrix, AbstractMatrix}" href="#GeometricOptimizers.metric-Tuple{GrassmannManifold, AbstractMatrix, AbstractMatrix}"><code>GeometricOptimizers.metric</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">metric(Y::GrassmannManifold, Δ₁::AbstractMatrix, Δ₂::AbstractMatrix)</code></pre><p>Compute the metric for vectors <code>Δ₁</code> and <code>Δ₂</code> at <code>Y</code>. </p><p>The representation of the Grassmann manifold is realized as a <em>quotient space of the Stiefel manifold</em>. </p><p>The metric for the Grassmann manifold is:</p><p class="math-container">\[g^{Gr}_Y(\Delta_1, \Delta_2) = g^{St}_Y(\Delta_1, \Delta_2) = \mathrm{Tr}(\Delta_1^T (\mathbb{I} - Y Y^T) \Delta_2) = \mathrm{Tr}(\Delta_1^T \Delta_2),\]</p><p>where we used that <span>$Y^T\Delta_i$</span> for <span>$i = 1, 2.$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricOptimizers.jl/blob/6f4b3d30e5da75b97306ec0085ca25a2503725eb/src/manifolds/grassmann_manifold.jl#L50-L63">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricOptimizers.metric-Tuple{StiefelManifold, AbstractMatrix, AbstractMatrix}" href="#GeometricOptimizers.metric-Tuple{StiefelManifold, AbstractMatrix, AbstractMatrix}"><code>GeometricOptimizers.metric</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">metric(Y::StiefelManifold, Δ₁::AbstractMatrix, Δ₂::AbstractMatrix)</code></pre><p>Compute the dot product for <code>Δ₁</code> and <code>Δ₂</code> at <code>Y</code>.</p><p>This uses the canonical Riemannian metric for the Stiefel manifold:</p><p class="math-container">\[g_Y: (\Delta_1, \Delta_2) \mapsto \mathrm{Tr}(\Delta_1^T(\mathbb{I} - \frac{1}{2}YY^T)\Delta_2).\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricOptimizers.jl/blob/6f4b3d30e5da75b97306ec0085ca25a2503725eb/src/manifolds/stiefel_manifold.jl#L71-L80">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricOptimizers.optimization_step!-Tuple{Optimizer, NamedTuple, NamedTuple, NamedTuple}" href="#GeometricOptimizers.optimization_step!-Tuple{Optimizer, NamedTuple, NamedTuple, NamedTuple}"><code>GeometricOptimizers.optimization_step!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">optimization_step!(o, λY, ps, dx)</code></pre><p>Update the weights <code>ps</code> based on an <a href="#GeometricOptimizers.Optimizer"><code>Optimizer</code></a>, a <code>cache</code> and first-order derivatives <code>dx</code>.</p><p><code>optimization_step!</code> is calling <a href="#GeometricOptimizers.update!-Tuple{Optimizer, GeometricOptimizers.AbstractCache, AbstractArray}"><code>update!</code></a> internally.  <code>update!</code> has to be implemented for every <a href="#GeometricOptimizers.OptimizerMethod"><code>OptimizerMethod</code></a>.</p><p><strong>Arguments</strong></p><p>All arguments into <code>optimization_step!</code> are mandatory:</p><ol><li><code>o::</code><a href="#GeometricOptimizers.Optimizer"><code>Optimizer</code></a>,</li><li><code>λY::NamedTuple</code>: this named tuple has the same keys as <code>ps</code>, but contains <a href="#GeometricOptimizers.GlobalSection"><code>GlobalSection</code></a>s,</li><li><code>ps::NamedTuple</code>: the neural network parameters,</li><li><code>dx::NamedTuple</code>: the gradients stores as a NamedTuple.</li></ol><p>All the arguments are given as <code>NamedTuple</code>s  as the neural network weights are stores in that format.</p><pre><code class="language-julia hljs">using GeometricOptimizers
using GeometricOptimizers: MomentumCache, Momentum, apply_toNT, geodesic, optimization_step!

ps = (weight = rand(StiefelManifold{Float32}, 5, 3), )
cache = apply_toNT(MomentumCache, ps)
o = Optimizer(Momentum(), cache, 0, geodesic)
λY = GlobalSection(ps)
dx = (weight = rand(Float32, 5, 3), )

# call the optimizer
optimization_step!(o, λY, ps, dx)

_test_nt(x) = typeof(x) &lt;: NamedTuple

_test_nt(λY) &amp; _test_nt(ps) &amp; _test_nt(cache) &amp; _test_nt(dx)

# output

true</code></pre><p><strong>Extended help</strong></p><p>The derivatives <code>dx</code> here are usually obtained via an AD routine by differentiating a loss function, i.e. <code>dx</code> is <span>$\nabla_xL$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricOptimizers.jl/blob/6f4b3d30e5da75b97306ec0085ca25a2503725eb/src/optimizers/optimizer.jl#L65-L108">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricOptimizers.rgrad-Tuple{GrassmannManifold, AbstractMatrix}" href="#GeometricOptimizers.rgrad-Tuple{GrassmannManifold, AbstractMatrix}"><code>GeometricOptimizers.rgrad</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rgrad(Y::GrassmannManifold, ∇L::AbstractMatrix)</code></pre><p>Compute the Riemannian gradient for the Grassmann manifold at <code>Y</code> based on <code>∇L</code>.</p><p>Here <span>$Y$</span> is a representation of <span>$\mathrm{span}(Y)\in{}Gr(n, N)$</span> and <span>$\nabla{}L\in\mathbb{R}^{N\times{}n}$</span> is the Euclidean gradient. </p><p>This gradient has the property that it is orthogonal to the space spanned by <span>$Y$</span>.</p><p>The precise form of the mapping is: </p><p class="math-container">\[\mathtt{rgrad}(Y, \nabla{}L) \mapsto \nabla{}L - YY^T\nabla{}L.\]</p><p>Note the property <span>$Y^T\mathrm{rgrad}(Y, \nabla{}L) = \mathbb{O}.$</span></p><p>Also see <a href="#GeometricOptimizers.rgrad-Tuple{StiefelManifold, AbstractMatrix}"><code>rgrad(::StiefelManifold, ::AbstractMatrix)</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using GeometricOptimizers

Y = GrassmannManifold([1 0 ; 0 1 ; 0 0; 0 0])
Δ = [1 2; 3 4; 5 6; 7 8]
rgrad(Y, Δ)

# output

4×2 Matrix{Int64}:
 0  0
 0  0
 5  6
 7  8</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricOptimizers.jl/blob/6f4b3d30e5da75b97306ec0085ca25a2503725eb/src/manifolds/grassmann_manifold.jl#L10-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricOptimizers.rgrad-Tuple{StiefelManifold, AbstractMatrix}" href="#GeometricOptimizers.rgrad-Tuple{StiefelManifold, AbstractMatrix}"><code>GeometricOptimizers.rgrad</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rgrad(Y::StiefelManifold, ∇L::AbstractMatrix)</code></pre><p>Compute the Riemannian gradient for the Stiefel manifold at <code>Y</code> based on <code>∇L</code>.</p><p>Here <span>$Y\in{}St(N,n)$</span> and <span>$\nabla{}L\in\mathbb{R}^{N\times{}n}$</span> is the Euclidean gradient. </p><p>The function computes the Riemannian gradient with respect to the canonical metric: <a href="#GeometricOptimizers.metric-Tuple{StiefelManifold, AbstractMatrix, AbstractMatrix}"><code>metric(::StiefelManifold, ::AbstractMatrix, ::AbstractMatrix)</code></a>.</p><p>The precise form of the mapping is: </p><p class="math-container">\[\mathtt{rgrad}(Y, \nabla{}L) \mapsto \nabla{}L - Y(\nabla{}L)^TY\]</p><p>Note the property <span>$Y^T\mathtt{rgrad}(Y, \nabla{}L)\in\mathcal{S}_\mathrm{skew}(n).$</span></p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using GeometricOptimizers

Y = StiefelManifold([1 0 ; 0 1 ; 0 0; 0 0])
Δ = [1 2; 3 4; 5 6; 7 8]
rgrad(Y, Δ)

# output

4×2 Matrix{Int64}:
 0  -1
 1   0
 5   6
 7   8</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricOptimizers.jl/blob/6f4b3d30e5da75b97306ec0085ca25a2503725eb/src/manifolds/stiefel_manifold.jl#L32-L66">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricOptimizers.update!-Tuple{Optimizer, GeometricOptimizers.AbstractCache, AbstractArray}" href="#GeometricOptimizers.update!-Tuple{Optimizer, GeometricOptimizers.AbstractCache, AbstractArray}"><code>GeometricOptimizers.update!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update!(o, cache, B)</code></pre><p>Update the <code>cache</code> and output a final velocity that is stored in <code>B</code>.</p><p>Note that <span>$B\in\mathfrak{g}^\mathrm{hor}$</span> in general.</p><p>In the manifold case the final velocity is the input to a retraction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricOptimizers.jl/blob/6f4b3d30e5da75b97306ec0085ca25a2503725eb/src/optimizers/optimizer.jl#L40-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricOptimizers.update!-Tuple{Optimizer{&lt;:GeometricOptimizers.BFGS}, GeometricOptimizers.BFGSCache, AbstractArray}" href="#GeometricOptimizers.update!-Tuple{Optimizer{&lt;:GeometricOptimizers.BFGS}, GeometricOptimizers.BFGSCache, AbstractArray}"><code>GeometricOptimizers.update!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update!(o::Optimizer{&lt;:BFGS}, C, B)</code></pre><p>Peform an update with the BFGS optimizer. </p><p><code>C</code> is the cache, <code>B</code> contains the gradient information (the output of <a href="#GeometricOptimizers.global_rep-Union{Tuple{AT}, Tuple{T}, Tuple{GlobalSection{T, AT}, AbstractMatrix{T}}} where {T, AT&lt;:(GrassmannManifold{T, AT} where AT&lt;:AbstractMatrix{T})}"><code>global_rep</code></a> in general).</p><p>First we compute the <em>final velocity</em> with</p><pre><code class="language-julia hljs">vecS = -o.method.η * C.H * vec(B)</code></pre><p>and then we update <code>H</code></p><pre><code class="language-julia hljs">C.H .= (𝕀 - ρ * SY) * C.H * (𝕀 - ρ * SY&#39;) + ρ * vecS * vecS&#39;</code></pre><p>where <code>SY</code> is <code>vecS * Y&#39;</code> and <code>𝕀</code> is the idendity. </p><p><strong>Implementation</strong></p><p>For stability we use <code>δ</code> for computing <code>ρ</code>:</p><pre><code class="language-julia hljs">ρ = 1. / (vecS&#39; * Y + o.method.δ)</code></pre><p>This is similar to the <a href="#GeometricOptimizers.Adam"><code>Adam</code></a></p><p><strong>Extended help</strong></p><p>If we have weights on a <a href="#GeometricOptimizers.Manifold"><code>Manifold</code></a> than the updates are slightly more difficult. In this case the <a href="#Base.vec-Tuple{GeometricOptimizers.AbstractTriangular}"><code>vec</code></a> operation has to be generalized to the corresponding <em>global tangent space</em>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricOptimizers.jl/blob/6f4b3d30e5da75b97306ec0085ca25a2503725eb/src/optimizers/bfgs_optimizer.jl#L18-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricOptimizers.Ω-Union{Tuple{T}, Tuple{GrassmannManifold{T, AT} where AT&lt;:AbstractMatrix{T}, AbstractMatrix{T}}} where T" href="#GeometricOptimizers.Ω-Union{Tuple{T}, Tuple{GrassmannManifold{T, AT} where AT&lt;:AbstractMatrix{T}, AbstractMatrix{T}}} where T"><code>GeometricOptimizers.Ω</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Ω(Y::GrassmannManifold{T}, Δ::AbstractMatrix{T}) where T</code></pre><p>Perform the <em>canonical horizontal lift</em> for the Grassmann manifold:</p><p class="math-container">\[    \Delta \mapsto \Omega^{St}(\Delta),\]</p><p>where <span>$\Omega^{St}$</span> is the canonical horizontal lift for the Stiefel manifold.</p><pre><code class="language-julia hljs">using GeometricOptimizers
using GeometricOptimizers: StiefelProjection

E = GrassmannManifold(StiefelProjection(5, 2))
Δ = [0. 0.; 0. 0.; 2. 3.; 4. 5.; 6. 7.]
GeometricOptimizers.Ω(E, Δ)

# output

5×5 SkewSymMatrix{Float64, Vector{Float64}}:
 0.0  -0.0  -2.0  -4.0  -6.0
 0.0   0.0  -3.0  -5.0  -7.0
 2.0   3.0   0.0  -0.0  -0.0
 4.0   5.0   0.0   0.0  -0.0
 6.0   7.0   0.0   0.0   0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricOptimizers.jl/blob/6f4b3d30e5da75b97306ec0085ca25a2503725eb/src/global_sections/omega_functions.jl#L45-L73">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricOptimizers.Ω-Union{Tuple{T}, Tuple{StiefelManifold{T, AT} where AT&lt;:AbstractMatrix{T}, AbstractMatrix{T}}} where T" href="#GeometricOptimizers.Ω-Union{Tuple{T}, Tuple{StiefelManifold{T, AT} where AT&lt;:AbstractMatrix{T}, AbstractMatrix{T}}} where T"><code>GeometricOptimizers.Ω</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Ω(Y::StiefelManifold{T}, Δ::AbstractMatrix{T}) where T</code></pre><p>Perform <em>canonical horizontal lift</em> for the Stiefel manifold:</p><p class="math-container">\[    \Delta \mapsto (\mathbb{I} - \frac{1}{2}YY^T)\Delta{}Y^T - Y\Delta^T(\mathbb{I} - \frac{1}{2}YY^T).\]</p><p>Internally this performs </p><pre><code class="language-julia hljs">SkewSymMatrix(2 * (I(n) - .5 * Y * Y&#39;) * Δ * Y&#39;)</code></pre><p>It uses <a href="#GeometricOptimizers.SkewSymMatrix"><code>SkewSymMatrix</code></a> to save memory. </p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using GeometricOptimizers
using GeometricOptimizers: StiefelProjection

E = StiefelManifold(StiefelProjection(5, 2))
Δ = [0. -1.; 1. 0.; 2. 3.; 4. 5.; 6. 7.]
GeometricOptimizers.Ω(E, Δ)

# output

5×5 SkewSymMatrix{Float64, Vector{Float64}}:
 0.0  -1.0  -2.0  -4.0  -6.0
 1.0   0.0  -3.0  -5.0  -7.0
 2.0   3.0   0.0  -0.0  -0.0
 4.0   5.0   0.0   0.0  -0.0
 6.0   7.0   0.0   0.0   0.0</code></pre><p>Note that the output of <code>Ω</code> is a skew-symmetric matrix, i.e. an element of <span>$\mathfrak{g}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricOptimizers.jl/blob/6f4b3d30e5da75b97306ec0085ca25a2503725eb/src/global_sections/omega_functions.jl#L1-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricOptimizers.𝔄-Tuple{AbstractMatrix, AbstractMatrix}" href="#GeometricOptimizers.𝔄-Tuple{AbstractMatrix, AbstractMatrix}"><code>GeometricOptimizers.𝔄</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">𝔄(B̂, B̄)</code></pre><p>Compute <span>$\mathfrak{A}(B&#39;, B&#39;&#39;) := \sum_{n=1}^\infty \frac{1}{n!} ((B&#39;&#39;)^TB&#39;)^{n-1}.$</span></p><p>This expression has the property <span>$\mathbb{I} +  B&#39;\mathfrak{A}(B&#39;, B&#39;&#39;)(B&#39;&#39;)^T = \exp(B&#39;(B&#39;&#39;)^T).$</span></p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using GeometricOptimizers
using GeometricOptimizers: 𝔄
import Random
Random.seed!(123)

B = rand(StiefelLieAlgHorMatrix, 10, 2)
B̂ = hcat(vcat(.5 * B.A, B.B), vcat(one(B.A), zero(B.B)))
B̄ = hcat(vcat(one(B.A), zero(B.B)), vcat(-.5 * B.A, -B.B))

one(B̂ * B̄&#39;) + B̂ * 𝔄(B̂, B̄) * B̄&#39; ≈ exp(Matrix(B))

# output

true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricOptimizers.jl/blob/6f4b3d30e5da75b97306ec0085ca25a2503725eb/src/retractions/modified_exponential.jl#L47-L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometricOptimizers.𝔄-Tuple{AbstractMatrix}" href="#GeometricOptimizers.𝔄-Tuple{AbstractMatrix}"><code>GeometricOptimizers.𝔄</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">𝔄(A)</code></pre><p>Compute <span>$\mathfrak{A}(A) := \sum_{n=1}^\infty \frac{1}{n!} (A)^{n-1}.$</span></p><p><strong>Implementation</strong></p><p>This uses a Taylor expansion that iteratively adds terms with</p><pre><code class="language-julia hljs">while norm(Aⁿ) &gt; ε
mul!(A_temp, Aⁿ, A)
Aⁿ .= A_temp
rmul!(Aⁿ, T(inv(n)))

𝔄A += Aⁿ
n += 1 
end</code></pre><p>until the norm of <code>Aⁿ</code> becomes smaller than machine precision.  The counter <code>n</code> in the above algorithm is initialized as <code>2</code> The matrices <code>Aⁿ</code> and <code>𝔄</code> are initialized as the identity matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricOptimizers.jl/blob/6f4b3d30e5da75b97306ec0085ca25a2503725eb/src/retractions/modified_exponential.jl#L10-L33">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="references/">References »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Thursday 9 January 2025 14:07">Thursday 9 January 2025</span>. Using Julia version 1.11.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
